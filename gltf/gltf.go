// Code generated by schema-generate. DO NOT EDIT.

package gltf

import (
	"bytes"
	"encoding/json"
	"errors"
)

// Extension
type Extension map[string]*Anonymous1

// Extras
type Extras interface{}

// GlTFId
type GlTFId int

// Accessor A typed view into a bufferView.  A bufferView contains raw binary data.  An accessor provides a typed view into a bufferView or a subset of a bufferView similar to how WebGL's `vertexAttribPointer()` defines an attribute in a buffer.
type Accessor struct {

	// The index of the bufferView.
	BufferView int `json:"bufferView,omitempty"`

	// The offset relative to the start of the bufferView in bytes.
	ByteOffset int `json:"byteOffset,omitempty"`

	// The datatype of components in the attribute.
	ComponentType int `json:"componentType"`

	// The number of attributes referenced by this accessor.
	Count      int         `json:"count"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// Maximum value of each component in this attribute.
	Max []float64 `json:"max,omitempty"`

	// Minimum value of each component in this attribute.
	Min  []float64 `json:"min,omitempty"`
	Name string    `json:"name,omitempty"`

	// Specifies whether integer data values should be normalized.
	Normalized bool `json:"normalized,omitempty"`

	// Sparse storage of attributes that deviate from their initialization value.
	Sparse interface{} `json:"sparse,omitempty"`

	// Specifies if the attribute is a scalar, vector, or matrix.
	Type string `json:"type"`
}

// AccessorSparse Sparse storage of attributes that deviate from their initialization value.
type AccessorSparse struct {

	// Number of entries stored in the sparse array.
	Count      int         `json:"count"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// Index array of size `count` that points to those accessor attributes that deviate from their initialization value. Indices must strictly increase.
	Indices interface{} `json:"indices"`

	// Array of size `count` times number of components, storing the displaced accessor attributes pointed by `indices`. Substituted values must have the same `componentType` and number of components as the base accessor.
	Values interface{} `json:"values"`
}

// AccessorSparseIndices Indices of those attributes that deviate from their initialization value.
type AccessorSparseIndices struct {

	// The index of the bufferView with sparse indices. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
	BufferView interface{} `json:"bufferView"`

	// The offset relative to the start of the bufferView in bytes. Must be aligned.
	ByteOffset int `json:"byteOffset,omitempty"`

	// The indices data type.
	ComponentType interface{} `json:"componentType"`
	Extensions    interface{} `json:"extensions,omitempty"`
	Extras        interface{} `json:"extras,omitempty"`
}

// AccessorSparseValues Array of size `accessor.sparse.count` times number of components storing the displaced accessor attributes pointed by `accessor.sparse.indices`.
type AccessorSparseValues struct {

	// The index of the bufferView with sparse values. Referenced bufferView can't have ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target.
	BufferView interface{} `json:"bufferView"`

	// The offset relative to the start of the bufferView in bytes. Must be aligned.
	ByteOffset int         `json:"byteOffset,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
}

// Animation A keyframe animation.
type Animation struct {

	// An array of channels, each of which targets an animation's sampler at a node's property. Different channels of the same animation can't have equal targets.
	Channels   []*AnimationChannel `json:"channels"`
	Extensions interface{}         `json:"extensions,omitempty"`
	Extras     interface{}         `json:"extras,omitempty"`
	Name       interface{}         `json:"name,omitempty"`

	// An array of samplers that combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
	Samplers []*AnimationSampler `json:"samplers"`
}

// AnimationChannel Targets an animation's sampler at a node's property.
type AnimationChannel struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The index of a sampler in this animation used to compute the value for the target.
	Sampler interface{} `json:"sampler"`

	// The index of the node and TRS property to target.
	Target interface{} `json:"target"`
}

// AnimationChannelTarget The index of the node and TRS property that an animation channel targets.
type AnimationChannelTarget struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The index of the node to target.
	Node interface{} `json:"node,omitempty"`

	// The name of the node's TRS property to modify, or the "weights" of the Morph Targets it instantiates. For the "translation" property, the values that are provided by the sampler are the translation along the x, y, and z axes. For the "rotation" property, the values are a quaternion in the order (x, y, z, w), where w is the scalar. For the "scale" property, the values are the scaling factors along the x, y, and z axes.
	Path interface{} `json:"path"`
}

// AnimationSampler Combines input and output accessors with an interpolation algorithm to define a keyframe graph (but not its target).
type AnimationSampler struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The index of an accessor containing keyframe input values, e.g., time.
	Input interface{} `json:"input"`

	// Interpolation algorithm.
	Interpolation interface{} `json:"interpolation,omitempty"`

	// The index of an accessor, containing keyframe output values.
	Output interface{} `json:"output"`
}

// Anonymous1
type Anonymous1 struct {
}

// Asset Metadata about the glTF asset.
type Meta struct {

	// A copyright message suitable for display to credit the content creator.
	Copyright  string      `json:"copyright,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// Tool that generated this glTF model.  Useful for debugging.
	Generator string `json:"generator,omitempty"`

	// The minimum glTF version that this asset targets.
	MinVersion string `json:"minVersion,omitempty"`

	// The glTF version that this asset targets.
	Version string `json:"version"`
}

// Buffer A buffer points to binary geometry, animation, or skins.
type Buffer struct {

	// The length of the buffer in bytes.
	ByteLength int         `json:"byteLength"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       interface{} `json:"name,omitempty"`

	// The uri of the buffer.
	Uri string `json:"uri,omitempty"`
}

// BufferView A view into a buffer generally representing a subset of the buffer.
type BufferView struct {

	// The index of the buffer.
	Buffer int `json:"buffer"`

	// The length of the bufferView in bytes.
	ByteLength int `json:"byteLength"`

	// The offset into the buffer in bytes.
	ByteOffset int `json:"byteOffset,omitempty"`

	// The stride, in bytes.
	ByteStride int         `json:"byteStride,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       string      `json:"name,omitempty"`

	// The target that the GPU buffer should be bound to.
	Target int `json:"target,omitempty"`
}

// Camera A camera's projection.  A node can reference a camera to apply a transform to place the camera in the scene.
type Camera struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       string      `json:"name,omitempty"`

	// An orthographic camera containing properties to create an orthographic projection matrix.
	Orthographic CameraOrthographic `json:"orthographic,omitempty"`

	// A perspective camera containing properties to create a perspective projection matrix.
	Perspective CameraPerspective `json:"perspective,omitempty"`

	// Specifies if the camera uses a perspective or orthographic projection.
	Type string `json:"type"`
}

// CameraOrthographic An orthographic camera containing properties to create an orthographic projection matrix.
type CameraOrthographic struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The floating-point horizontal magnification of the view. Must not be zero.
	Xmag float64 `json:"xmag"`

	// The floating-point vertical magnification of the view. Must not be zero.
	Ymag float64 `json:"ymag"`

	// The floating-point distance to the far clipping plane. `zfar` must be greater than `znear`.
	Zfar float64 `json:"zfar"`

	// The floating-point distance to the near clipping plane.
	Znear float64 `json:"znear"`
}

// CameraPerspective A perspective camera containing properties to create a perspective projection matrix.
type CameraPerspective struct {

	// The floating-point aspect ratio of the field of view.
	AspectRatio float64     `json:"aspectRatio,omitempty"`
	Extensions  interface{} `json:"extensions,omitempty"`
	Extras      interface{} `json:"extras,omitempty"`

	// The floating-point vertical field of view in radians.
	Yfov float64 `json:"yfov"`

	// The floating-point distance to the far clipping plane.
	Zfar float64 `json:"zfar,omitempty"`

	// The floating-point distance to the near clipping plane.
	Znear float64 `json:"znear"`
}

// GlTF The root object for a glTF asset.
type GlTF struct {

	// An array of accessors.
	Accessors []*Accessor `json:"accessors,omitempty"`

	// An array of keyframe animations.
	Animations []*Animation `json:"animations,omitempty"`

	// Metadata about the glTF asset.
	Asset Meta `json:"asset"`

	// An array of bufferViews.
	BufferViews []*BufferView `json:"bufferViews,omitempty"`

	// An array of buffers.
	Buffers []*Buffer `json:"buffers,omitempty"`

	// An array of cameras.
	Cameras    []*Camera   `json:"cameras,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`

	// Names of glTF extensions required to properly load this asset.
	ExtensionsRequired []string `json:"extensionsRequired,omitempty"`

	// Names of glTF extensions used somewhere in this asset.
	ExtensionsUsed []string    `json:"extensionsUsed,omitempty"`
	Extras         interface{} `json:"extras,omitempty"`

	// An array of images.
	Images []*Image `json:"images,omitempty"`

	// An array of materials.
	Materials []*Material `json:"materials,omitempty"`

	// An array of meshes.
	Meshes []*Mesh `json:"meshes,omitempty"`

	// An array of nodes.
	Nodes []*Node `json:"nodes,omitempty"`

	// An array of samplers.
	Samplers []*Sampler `json:"samplers,omitempty"`

	// The index of the default scene.
	Scene int `json:"scene,omitempty"`

	// An array of scenes.
	Scenes []*Scene `json:"scenes,omitempty"`

	// An array of skins.
	Skins []*Skin `json:"skins,omitempty"`

	// An array of textures.
	Textures []*Texture `json:"textures,omitempty"`
}

// GlTFChildOfRootProperty
type GlTFChildOfRootProperty struct {

	// The user-defined name of this object.
	Name string `json:"name,omitempty"`
}

// GlTFProperty
type GlTFProperty struct {
	Extensions *Extension  `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
}

// Image Image data used to create a texture. Image can be referenced by URI or `bufferView` index. `mimeType` is required in the latter case.
type Image struct {

	// The index of the bufferView that contains the image. Use this instead of the image's uri property.
	BufferView interface{} `json:"bufferView,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The image's MIME type. Required if `bufferView` is defined.
	MimeType interface{} `json:"mimeType,omitempty"`
	Name     interface{} `json:"name,omitempty"`

	// The uri of the image.
	Uri string `json:"uri,omitempty"`
}

// Material The material appearance of a primitive.
type Material struct {

	// The alpha cutoff value of the material.
	AlphaCutoff float64 `json:"alphaCutoff,omitempty"`

	// The alpha rendering mode of the material.
	AlphaMode int `json:"alphaMode,omitempty"`

	// Specifies whether the material is double sided.
	DoubleSided bool `json:"doubleSided,omitempty"`

	// The emissive color of the material.
	EmissiveFactor []float64 `json:"emissiveFactor,omitempty"`

	// The emissive map texture.
	EmissiveTexture int         `json:"emissiveTexture,omitempty"`
	Extensions      interface{} `json:"extensions,omitempty"`
	Extras          interface{} `json:"extras,omitempty"`
	Name            string      `json:"name,omitempty"`

	// The normal map texture.
	NormalTexture MaterialNormalTextureInfo `json:"normalTexture,omitempty"`

	// The occlusion map texture.
	OcclusionTexture MaterialOcclusionTextureInfo `json:"occlusionTexture,omitempty"`

	// A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology. When not specified, all the default values of `pbrMetallicRoughness` apply.
	PbrMetallicRoughness MaterialPBRMetallicRoughness `json:"pbrMetallicRoughness,omitempty"`
}

// MaterialNormalTextureInfo
type MaterialNormalTextureInfo struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Index      int         `json:"index,omitempty"`

	// The scalar multiplier applied to each normal vector of the normal texture.
	Scale    float64 `json:"scale,omitempty"`
	TexCoord int     `json:"texCoord,omitempty"`
}

// MaterialOcclusionTextureInfo
type MaterialOcclusionTextureInfo struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Index      int         `json:"index,omitempty"`

	// A scalar multiplier controlling the amount of occlusion applied.
	Strength float64 `json:"strength,omitempty"`
	TexCoord int     `json:"texCoord,omitempty"`
}

// MaterialPBRMetallicRoughness A set of parameter values that are used to define the metallic-roughness material model from Physically-Based Rendering (PBR) methodology.
type MaterialPBRMetallicRoughness struct {

	// The material's base color factor.
	BaseColorFactor []float64 `json:"baseColorFactor,omitempty"`

	// The base color texture.
	BaseColorTexture int         `json:"baseColorTexture,omitempty"`
	Extensions       interface{} `json:"extensions,omitempty"`
	Extras           interface{} `json:"extras,omitempty"`

	// The metalness of the material.
	MetallicFactor float64 `json:"metallicFactor,omitempty"`

	// The metallic-roughness texture.
	MetallicRoughnessTexture int `json:"metallicRoughnessTexture,omitempty"`

	// The roughness of the material.
	RoughnessFactor float64 `json:"roughnessFactor,omitempty"`
}

// Mesh A set of primitives to be rendered.  A node can contain one mesh.  A node's transform places the mesh in the scene.
type Mesh struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       string      `json:"name,omitempty"`

	// An array of primitives, each defining geometry to be rendered with a material.
	Primitives []*MeshPrimitive `json:"primitives"`

	// Array of weights to be applied to the Morph Targets.
	Weights []float64 `json:"weights,omitempty"`
}

// MeshPrimitive Geometry to be rendered with the given material.
type MeshPrimitive struct {

	// A dictionary object, where each key corresponds to mesh attribute semantic and each value is the index of the accessor containing attribute's data.
	Attributes map[string]int `json:"attributes"`
	Extensions interface{}    `json:"extensions,omitempty"`
	Extras     interface{}    `json:"extras,omitempty"`

	// The index of the accessor that contains the indices.
	Indices int `json:"indices,omitempty"`

	// The index of the material to apply to this primitive when rendering.
	Material int `json:"material,omitempty"`

	// The type of primitives to render.
	Mode int `json:"mode,omitempty"`

	// An array of Morph Targets, each  Morph Target is a dictionary mapping attributes (only `POSITION`, `NORMAL`, and `TANGENT` supported) to their deviations in the Morph Target.
	Targets []map[string]int `json:"targets,omitempty"`
}

// Node A node in the node hierarchy.  When the node contains `skin`, all `mesh.primitives` must contain `JOINTS_0` and `WEIGHTS_0` attributes.  A node can have either a `matrix` or any combination of `translation`/`rotation`/`scale` (TRS) properties. TRS properties are converted to matrices and postmultiplied in the `T * R * S` order to compose the transformation matrix; first the scale is applied to the vertices, then the rotation, and then the translation. If none are provided, the transform is the identity. When a node is targeted for animation (referenced by an animation.channel.target), only TRS properties may be present; `matrix` will not be present.
type Node struct {

	// The index of the camera referenced by this node.
	Camera int `json:"camera,omitempty"`

	// The indices of this node's children.
	Children   []int       `json:"children,omitempty"`
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// A floating-point 4x4 transformation matrix stored in column-major order.
	Matrix []float64 `json:"matrix,omitempty"`

	// The index of the mesh in this node.
	Mesh int    `json:"mesh,omitempty"`
	Name string `json:"name,omitempty"`

	// The node's unit quaternion rotation in the order (x, y, z, w), where w is the scalar.
	Rotation []float64 `json:"rotation,omitempty"`

	// The node's non-uniform scale, given as the scaling factors along the x, y, and z axes.
	Scale []float64 `json:"scale,omitempty"`

	// The index of the skin referenced by this node.
	Skin int `json:"skin,omitempty"`

	// The node's translation along the x, y, and z axes.
	Translation []float64 `json:"translation,omitempty"`

	// The weights of the instantiated Morph Target. Number of elements must match number of Morph Targets of used mesh.
	Weights []float64 `json:"weights,omitempty"`
}

// Sampler Texture sampler properties for filtering and wrapping modes.
type Sampler struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// Magnification filter.
	MagFilter int `json:"magFilter,omitempty"`

	// Minification filter.
	MinFilter int    `json:"minFilter,omitempty"`
	Name      string `json:"name,omitempty"`

	// s wrapping mode.
	WrapS int `json:"wrapS,omitempty"`

	// t wrapping mode.
	WrapT int `json:"wrapT,omitempty"`
}

// Scene The root nodes of a scene.
type Scene struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       string      `json:"name,omitempty"`

	// The indices of each root node.
	Nodes []int `json:"nodes,omitempty"`
}

// Skin Joints and matrices defining a skin.
type Skin struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The index of the accessor containing the floating-point 4x4 inverse-bind matrices.  The default is that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were pre-applied.
	InverseBindMatrices int `json:"inverseBindMatrices,omitempty"`

	// Indices of skeleton nodes, used as joints in this skin.
	Joints []int  `json:"joints"`
	Name   string `json:"name,omitempty"`

	// The index of the node used as a skeleton root.
	Skeleton int `json:"skeleton,omitempty"`
}

// Texture A texture and its sampler.
type Texture struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`
	Name       string      `json:"name,omitempty"`

	// The index of the sampler used by this texture. When undefined, a sampler with repeat wrapping and auto filtering should be used.
	Sampler Sampler `json:"sampler,omitempty"`

	// The index of the image used by this texture. When undefined, it is expected that an extension or other mechanism will supply an alternate texture source, otherwise behavior is undefined.
	Source interface{} `json:"source,omitempty"`
}

// TextureInfo Reference to a texture.
type TextureInfo struct {
	Extensions interface{} `json:"extensions,omitempty"`
	Extras     interface{} `json:"extras,omitempty"`

	// The index of the texture.
	Index interface{} `json:"index"`

	// The set index of texture's TEXCOORD attribute used for texture coordinate mapping.
	TexCoord int `json:"texCoord,omitempty"`
}

func (strct *Accessor) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "bufferView" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bufferView\": ")
	if tmp, err := json.Marshal(strct.BufferView); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "byteOffset" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteOffset\": ")
	if tmp, err := json.Marshal(strct.ByteOffset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ComponentType" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "componentType" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"componentType\": ")
	if tmp, err := json.Marshal(strct.ComponentType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Count" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "count" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "max" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"max\": ")
	if tmp, err := json.Marshal(strct.Max); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "min" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"min\": ")
	if tmp, err := json.Marshal(strct.Min); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "normalized" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"normalized\": ")
	if tmp, err := json.Marshal(strct.Normalized); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sparse" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sparse\": ")
	if tmp, err := json.Marshal(strct.Sparse); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Accessor) UnmarshalJSON(b []byte) error {
	componentTypeReceived := false
	countReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bufferView":
			if err := json.Unmarshal([]byte(v), &strct.BufferView); err != nil {
				return err
			}
		case "byteOffset":
			if err := json.Unmarshal([]byte(v), &strct.ByteOffset); err != nil {
				return err
			}
		case "componentType":
			if err := json.Unmarshal([]byte(v), &strct.ComponentType); err != nil {
				return err
			}
			componentTypeReceived = true
		case "count":
			if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
				return err
			}
			countReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "max":
			if err := json.Unmarshal([]byte(v), &strct.Max); err != nil {
				return err
			}
		case "min":
			if err := json.Unmarshal([]byte(v), &strct.Min); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "normalized":
			if err := json.Unmarshal([]byte(v), &strct.Normalized); err != nil {
				return err
			}
		case "sparse":
			if err := json.Unmarshal([]byte(v), &strct.Sparse); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if componentType (a required property) was received
	if !componentTypeReceived {
		return errors.New("\"componentType\" is required but was not present")
	}
	// check if count (a required property) was received
	if !countReceived {
		return errors.New("\"count\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *AccessorSparse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Count" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "count" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"count\": ")
	if tmp, err := json.Marshal(strct.Count); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Indices" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "indices" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"indices\": ")
	if tmp, err := json.Marshal(strct.Indices); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Values" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "values" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"values\": ")
	if tmp, err := json.Marshal(strct.Values); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessorSparse) UnmarshalJSON(b []byte) error {
	countReceived := false
	indicesReceived := false
	valuesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "count":
			if err := json.Unmarshal([]byte(v), &strct.Count); err != nil {
				return err
			}
			countReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "indices":
			if err := json.Unmarshal([]byte(v), &strct.Indices); err != nil {
				return err
			}
			indicesReceived = true
		case "values":
			if err := json.Unmarshal([]byte(v), &strct.Values); err != nil {
				return err
			}
			valuesReceived = true
		}
	}
	// check if count (a required property) was received
	if !countReceived {
		return errors.New("\"count\" is required but was not present")
	}
	// check if indices (a required property) was received
	if !indicesReceived {
		return errors.New("\"indices\" is required but was not present")
	}
	// check if values (a required property) was received
	if !valuesReceived {
		return errors.New("\"values\" is required but was not present")
	}
	return nil
}

func (strct *AccessorSparseIndices) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "BufferView" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "bufferView" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bufferView\": ")
	if tmp, err := json.Marshal(strct.BufferView); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "byteOffset" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteOffset\": ")
	if tmp, err := json.Marshal(strct.ByteOffset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ComponentType" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "componentType" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"componentType\": ")
	if tmp, err := json.Marshal(strct.ComponentType); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessorSparseIndices) UnmarshalJSON(b []byte) error {
	bufferViewReceived := false
	componentTypeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bufferView":
			if err := json.Unmarshal([]byte(v), &strct.BufferView); err != nil {
				return err
			}
			bufferViewReceived = true
		case "byteOffset":
			if err := json.Unmarshal([]byte(v), &strct.ByteOffset); err != nil {
				return err
			}
		case "componentType":
			if err := json.Unmarshal([]byte(v), &strct.ComponentType); err != nil {
				return err
			}
			componentTypeReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		}
	}
	// check if bufferView (a required property) was received
	if !bufferViewReceived {
		return errors.New("\"bufferView\" is required but was not present")
	}
	// check if componentType (a required property) was received
	if !componentTypeReceived {
		return errors.New("\"componentType\" is required but was not present")
	}
	return nil
}

func (strct *AccessorSparseValues) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "BufferView" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "bufferView" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bufferView\": ")
	if tmp, err := json.Marshal(strct.BufferView); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "byteOffset" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteOffset\": ")
	if tmp, err := json.Marshal(strct.ByteOffset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccessorSparseValues) UnmarshalJSON(b []byte) error {
	bufferViewReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "bufferView":
			if err := json.Unmarshal([]byte(v), &strct.BufferView); err != nil {
				return err
			}
			bufferViewReceived = true
		case "byteOffset":
			if err := json.Unmarshal([]byte(v), &strct.ByteOffset); err != nil {
				return err
			}
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		}
	}
	// check if bufferView (a required property) was received
	if !bufferViewReceived {
		return errors.New("\"bufferView\" is required but was not present")
	}
	return nil
}

func (strct *Animation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Channels" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "channels" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"channels\": ")
	if tmp, err := json.Marshal(strct.Channels); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Samplers" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "samplers" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"samplers\": ")
	if tmp, err := json.Marshal(strct.Samplers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Animation) UnmarshalJSON(b []byte) error {
	channelsReceived := false
	samplersReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "channels":
			if err := json.Unmarshal([]byte(v), &strct.Channels); err != nil {
				return err
			}
			channelsReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "samplers":
			if err := json.Unmarshal([]byte(v), &strct.Samplers); err != nil {
				return err
			}
			samplersReceived = true
		}
	}
	// check if channels (a required property) was received
	if !channelsReceived {
		return errors.New("\"channels\" is required but was not present")
	}
	// check if samplers (a required property) was received
	if !samplersReceived {
		return errors.New("\"samplers\" is required but was not present")
	}
	return nil
}

func (strct *AnimationChannel) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Sampler" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "sampler" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sampler\": ")
	if tmp, err := json.Marshal(strct.Sampler); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Target" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "target" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AnimationChannel) UnmarshalJSON(b []byte) error {
	samplerReceived := false
	targetReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "sampler":
			if err := json.Unmarshal([]byte(v), &strct.Sampler); err != nil {
				return err
			}
			samplerReceived = true
		case "target":
			if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
				return err
			}
			targetReceived = true
		}
	}
	// check if sampler (a required property) was received
	if !samplerReceived {
		return errors.New("\"sampler\" is required but was not present")
	}
	// check if target (a required property) was received
	if !targetReceived {
		return errors.New("\"target\" is required but was not present")
	}
	return nil
}

func (strct *AnimationChannelTarget) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "node" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"node\": ")
	if tmp, err := json.Marshal(strct.Node); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Path" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "path" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"path\": ")
	if tmp, err := json.Marshal(strct.Path); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AnimationChannelTarget) UnmarshalJSON(b []byte) error {
	pathReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "node":
			if err := json.Unmarshal([]byte(v), &strct.Node); err != nil {
				return err
			}
		case "path":
			if err := json.Unmarshal([]byte(v), &strct.Path); err != nil {
				return err
			}
			pathReceived = true
		}
	}
	// check if path (a required property) was received
	if !pathReceived {
		return errors.New("\"path\" is required but was not present")
	}
	return nil
}

func (strct *AnimationSampler) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Input" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "input" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"input\": ")
	if tmp, err := json.Marshal(strct.Input); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "interpolation" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"interpolation\": ")
	if tmp, err := json.Marshal(strct.Interpolation); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Output" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "output" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"output\": ")
	if tmp, err := json.Marshal(strct.Output); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AnimationSampler) UnmarshalJSON(b []byte) error {
	inputReceived := false
	outputReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "input":
			if err := json.Unmarshal([]byte(v), &strct.Input); err != nil {
				return err
			}
			inputReceived = true
		case "interpolation":
			if err := json.Unmarshal([]byte(v), &strct.Interpolation); err != nil {
				return err
			}
		case "output":
			if err := json.Unmarshal([]byte(v), &strct.Output); err != nil {
				return err
			}
			outputReceived = true
		}
	}
	// check if input (a required property) was received
	if !inputReceived {
		return errors.New("\"input\" is required but was not present")
	}
	// check if output (a required property) was received
	if !outputReceived {
		return errors.New("\"output\" is required but was not present")
	}
	return nil
}

func (strct *Meta) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "copyright" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"copyright\": ")
	if tmp, err := json.Marshal(strct.Copyright); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "generator" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"generator\": ")
	if tmp, err := json.Marshal(strct.Generator); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "minVersion" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"minVersion\": ")
	if tmp, err := json.Marshal(strct.MinVersion); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Version" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "version" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Meta) UnmarshalJSON(b []byte) error {
	versionReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "copyright":
			if err := json.Unmarshal([]byte(v), &strct.Copyright); err != nil {
				return err
			}
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "generator":
			if err := json.Unmarshal([]byte(v), &strct.Generator); err != nil {
				return err
			}
		case "minVersion":
			if err := json.Unmarshal([]byte(v), &strct.MinVersion); err != nil {
				return err
			}
		case "version":
			if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
				return err
			}
			versionReceived = true
		}
	}
	// check if version (a required property) was received
	if !versionReceived {
		return errors.New("\"version\" is required but was not present")
	}
	return nil
}

func (strct *Buffer) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "ByteLength" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "byteLength" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteLength\": ")
	if tmp, err := json.Marshal(strct.ByteLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "uri" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"uri\": ")
	if tmp, err := json.Marshal(strct.Uri); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Buffer) UnmarshalJSON(b []byte) error {
	byteLengthReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "byteLength":
			if err := json.Unmarshal([]byte(v), &strct.ByteLength); err != nil {
				return err
			}
			byteLengthReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "uri": //TODO URI reception should drive buffer retrieval
			if err := json.Unmarshal([]byte(v), &strct.Uri); err != nil {
				return err
			}
		}
	}
	// check if byteLength (a required property) was received
	if !byteLengthReceived {
		return errors.New("\"byteLength\" is required but was not present")
	}
	return nil
}

func (strct *BufferView) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Buffer" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "buffer" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"buffer\": ")
	if tmp, err := json.Marshal(strct.Buffer); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "ByteLength" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "byteLength" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteLength\": ")
	if tmp, err := json.Marshal(strct.ByteLength); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "byteOffset" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteOffset\": ")
	if tmp, err := json.Marshal(strct.ByteOffset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "byteStride" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"byteStride\": ")
	if tmp, err := json.Marshal(strct.ByteStride); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "target" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"target\": ")
	if tmp, err := json.Marshal(strct.Target); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BufferView) UnmarshalJSON(b []byte) error {
	bufferReceived := false
	byteLengthReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "buffer":
			if err := json.Unmarshal([]byte(v), &strct.Buffer); err != nil {
				return err
			}
			bufferReceived = true
		case "byteLength":
			if err := json.Unmarshal([]byte(v), &strct.ByteLength); err != nil {
				return err
			}
			byteLengthReceived = true
		case "byteOffset":
			if err := json.Unmarshal([]byte(v), &strct.ByteOffset); err != nil {
				return err
			}
		case "byteStride":
			if err := json.Unmarshal([]byte(v), &strct.ByteStride); err != nil {
				return err
			}
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "target":
			if err := json.Unmarshal([]byte(v), &strct.Target); err != nil {
				return err
			}
		}
	}
	// check if buffer (a required property) was received
	if !bufferReceived {
		return errors.New("\"buffer\" is required but was not present")
	}
	// check if byteLength (a required property) was received
	if !byteLengthReceived {
		return errors.New("\"byteLength\" is required but was not present")
	}
	return nil
}

func (strct *Camera) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "orthographic" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"orthographic\": ")
	if tmp, err := json.Marshal(strct.Orthographic); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "perspective" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"perspective\": ")
	if tmp, err := json.Marshal(strct.Perspective); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Camera) UnmarshalJSON(b []byte) error {
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "orthographic":
			if err := json.Unmarshal([]byte(v), &strct.Orthographic); err != nil {
				return err
			}
		case "perspective":
			if err := json.Unmarshal([]byte(v), &strct.Perspective); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *CameraOrthographic) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Xmag" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "xmag" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"xmag\": ")
	if tmp, err := json.Marshal(strct.Xmag); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Ymag" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "ymag" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"ymag\": ")
	if tmp, err := json.Marshal(strct.Ymag); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Zfar" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "zfar" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"zfar\": ")
	if tmp, err := json.Marshal(strct.Zfar); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Znear" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "znear" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"znear\": ")
	if tmp, err := json.Marshal(strct.Znear); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CameraOrthographic) UnmarshalJSON(b []byte) error {
	xmagReceived := false
	ymagReceived := false
	zfarReceived := false
	znearReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "xmag":
			if err := json.Unmarshal([]byte(v), &strct.Xmag); err != nil {
				return err
			}
			xmagReceived = true
		case "ymag":
			if err := json.Unmarshal([]byte(v), &strct.Ymag); err != nil {
				return err
			}
			ymagReceived = true
		case "zfar":
			if err := json.Unmarshal([]byte(v), &strct.Zfar); err != nil {
				return err
			}
			zfarReceived = true
		case "znear":
			if err := json.Unmarshal([]byte(v), &strct.Znear); err != nil {
				return err
			}
			znearReceived = true
		}
	}
	// check if xmag (a required property) was received
	if !xmagReceived {
		return errors.New("\"xmag\" is required but was not present")
	}
	// check if ymag (a required property) was received
	if !ymagReceived {
		return errors.New("\"ymag\" is required but was not present")
	}
	// check if zfar (a required property) was received
	if !zfarReceived {
		return errors.New("\"zfar\" is required but was not present")
	}
	// check if znear (a required property) was received
	if !znearReceived {
		return errors.New("\"znear\" is required but was not present")
	}
	return nil
}

func (strct *CameraPerspective) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "aspectRatio" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"aspectRatio\": ")
	if tmp, err := json.Marshal(strct.AspectRatio); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Yfov" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "yfov" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"yfov\": ")
	if tmp, err := json.Marshal(strct.Yfov); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "zfar" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"zfar\": ")
	if tmp, err := json.Marshal(strct.Zfar); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Znear" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "znear" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"znear\": ")
	if tmp, err := json.Marshal(strct.Znear); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CameraPerspective) UnmarshalJSON(b []byte) error {
	yfovReceived := false
	znearReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "aspectRatio":
			if err := json.Unmarshal([]byte(v), &strct.AspectRatio); err != nil {
				return err
			}
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "yfov":
			if err := json.Unmarshal([]byte(v), &strct.Yfov); err != nil {
				return err
			}
			yfovReceived = true
		case "zfar":
			if err := json.Unmarshal([]byte(v), &strct.Zfar); err != nil {
				return err
			}
		case "znear":
			if err := json.Unmarshal([]byte(v), &strct.Znear); err != nil {
				return err
			}
			znearReceived = true
		}
	}
	// check if yfov (a required property) was received
	if !yfovReceived {
		return errors.New("\"yfov\" is required but was not present")
	}
	// check if znear (a required property) was received
	if !znearReceived {
		return errors.New("\"znear\" is required but was not present")
	}
	return nil
}

func (strct *GlTF) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "accessors" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"accessors\": ")
	if tmp, err := json.Marshal(strct.Accessors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "animations" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"animations\": ")
	if tmp, err := json.Marshal(strct.Animations); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Asset" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "asset" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"asset\": ")
	if tmp, err := json.Marshal(strct.Asset); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "bufferViews" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"bufferViews\": ")
	if tmp, err := json.Marshal(strct.BufferViews); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "buffers" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"buffers\": ")
	if tmp, err := json.Marshal(strct.Buffers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cameras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cameras\": ")
	if tmp, err := json.Marshal(strct.Cameras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensionsRequired" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensionsRequired\": ")
	if tmp, err := json.Marshal(strct.ExtensionsRequired); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensionsUsed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensionsUsed\": ")
	if tmp, err := json.Marshal(strct.ExtensionsUsed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "images" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"images\": ")
	if tmp, err := json.Marshal(strct.Images); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "materials" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"materials\": ")
	if tmp, err := json.Marshal(strct.Materials); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "meshes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"\": ")
	if tmp, err := json.Marshal(strct.Meshes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "nodes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"nodes\": ")
	if tmp, err := json.Marshal(strct.Nodes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "samplers" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"samplers\": ")
	if tmp, err := json.Marshal(strct.Samplers); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "scene" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"scene\": ")
	if tmp, err := json.Marshal(strct.Scene); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "scenes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"scenes\": ")
	if tmp, err := json.Marshal(strct.Scenes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "skins" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"skins\": ")
	if tmp, err := json.Marshal(strct.Skins); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "textures" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"textures\": ")
	if tmp, err := json.Marshal(strct.Textures); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GlTF) UnmarshalJSON(b []byte) error {
	assetReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "accessors":
			if err := json.Unmarshal([]byte(v), &strct.Accessors); err != nil {
				return err
			}
		case "animations":
			if err := json.Unmarshal([]byte(v), &strct.Animations); err != nil {
				return err
			}
		case "asset":
			if err := json.Unmarshal([]byte(v), &strct.Asset); err != nil {
				return err
			}
			assetReceived = true
		case "bufferViews":
			if err := json.Unmarshal([]byte(v), &strct.BufferViews); err != nil {
				return err
			}
		case "buffers": //TODO Query all URI for buffers
			if err := json.Unmarshal([]byte(v), &strct.Buffers); err != nil {
				return err
			}
		case "cameras":
			if err := json.Unmarshal([]byte(v), &strct.Cameras); err != nil {
				return err
			}
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extensionsRequired":
			if err := json.Unmarshal([]byte(v), &strct.ExtensionsRequired); err != nil {
				return err
			}
		case "extensionsUsed":
			if err := json.Unmarshal([]byte(v), &strct.ExtensionsUsed); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "images": //TODO Retrieve images from URI
			if err := json.Unmarshal([]byte(v), &strct.Images); err != nil {
				return err
			}
		case "materials":
			if err := json.Unmarshal([]byte(v), &strct.Materials); err != nil {
				return err
			}
		case "meshes":
			if err := json.Unmarshal([]byte(v), &strct.Meshes); err != nil {
				return err
			}
		case "nodes":
			if err := json.Unmarshal([]byte(v), &strct.Nodes); err != nil {
				return err
			}
		case "samplers":
			if err := json.Unmarshal([]byte(v), &strct.Samplers); err != nil {
				return err
			}
		case "scene":
			if err := json.Unmarshal([]byte(v), &strct.Scene); err != nil {
				return err
			}
		case "scenes":
			if err := json.Unmarshal([]byte(v), &strct.Scenes); err != nil {
				return err
			}
		case "skins":
			if err := json.Unmarshal([]byte(v), &strct.Skins); err != nil {
				return err
			}
		case "textures": //TODO Query all URIs from Textures
			if err := json.Unmarshal([]byte(v), &strct.Textures); err != nil {
				return err
			}
		}
	}
	// check if asset (a required property) was received
	if !assetReceived {
		return errors.New("\"asset\" is required but was not present")
	}
	return nil
}

func (strct *Mesh) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Primitives" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "primitives" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"primitives\": ")
	if tmp, err := json.Marshal(strct.Primitives); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "weights" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"weights\": ")
	if tmp, err := json.Marshal(strct.Weights); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Mesh) UnmarshalJSON(b []byte) error {
	primitivesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "primitives":
			if err := json.Unmarshal([]byte(v), &strct.Primitives); err != nil {
				return err
			}
			primitivesReceived = true
		case "weights":
			if err := json.Unmarshal([]byte(v), &strct.Weights); err != nil {
				return err
			}
		}
	}
	// check if primitives (a required property) was received
	if !primitivesReceived {
		return errors.New("\"primitives\" is required but was not present")
	}
	return nil
}

func (strct *MeshPrimitive) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Attributes" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "attributes" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"attributes\": ")
	if tmp, err := json.Marshal(strct.Attributes); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "indices" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"indices\": ")
	if tmp, err := json.Marshal(strct.Indices); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "material" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"material\": ")
	if tmp, err := json.Marshal(strct.Material); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "mode" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "targets" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"targets\": ")
	if tmp, err := json.Marshal(strct.Targets); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MeshPrimitive) UnmarshalJSON(b []byte) error {
	attributesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "attributes":
			if err := json.Unmarshal([]byte(v), &strct.Attributes); err != nil {
				return err
			}
			attributesReceived = true
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "indices":
			if err := json.Unmarshal([]byte(v), &strct.Indices); err != nil {
				return err
			}
		case "material":
			if err := json.Unmarshal([]byte(v), &strct.Material); err != nil {
				return err
			}
		case "mode":
			if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
				return err
			}
		case "targets":
			if err := json.Unmarshal([]byte(v), &strct.Targets); err != nil {
				return err
			}
		}
	}
	// check if attributes (a required property) was received
	if !attributesReceived {
		return errors.New("\"attributes\" is required but was not present")
	}
	return nil
}

func (strct *Skin) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "inverseBindMatrices" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"inverseBindMatrices\": ")
	if tmp, err := json.Marshal(strct.InverseBindMatrices); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Joints" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "joints" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"joints\": ")
	if tmp, err := json.Marshal(strct.Joints); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "skeleton" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"skeleton\": ")
	if tmp, err := json.Marshal(strct.Skeleton); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Skin) UnmarshalJSON(b []byte) error {
	jointsReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "inverseBindMatrices":
			if err := json.Unmarshal([]byte(v), &strct.InverseBindMatrices); err != nil {
				return err
			}
		case "joints":
			if err := json.Unmarshal([]byte(v), &strct.Joints); err != nil {
				return err
			}
			jointsReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "skeleton":
			if err := json.Unmarshal([]byte(v), &strct.Skeleton); err != nil {
				return err
			}
		}
	}
	// check if joints (a required property) was received
	if !jointsReceived {
		return errors.New("\"joints\" is required but was not present")
	}
	return nil
}

func (strct *TextureInfo) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extensions" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extensions\": ")
	if tmp, err := json.Marshal(strct.Extensions); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "extras" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extras\": ")
	if tmp, err := json.Marshal(strct.Extras); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Index" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "index" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "texCoord" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"texCoord\": ")
	if tmp, err := json.Marshal(strct.TexCoord); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TextureInfo) UnmarshalJSON(b []byte) error {
	indexReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extensions":
			if err := json.Unmarshal([]byte(v), &strct.Extensions); err != nil {
				return err
			}
		case "extras":
			if err := json.Unmarshal([]byte(v), &strct.Extras); err != nil {
				return err
			}
		case "index":
			if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
				return err
			}
			indexReceived = true
		case "texCoord":
			if err := json.Unmarshal([]byte(v), &strct.TexCoord); err != nil {
				return err
			}
		}
	}
	// check if index (a required property) was received
	if !indexReceived {
		return errors.New("\"index\" is required but was not present")
	}
	return nil
}
