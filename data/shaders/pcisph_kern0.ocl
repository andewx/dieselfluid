//PCISPH Shader - OpenCL Compute Shader Executes the advection and pressure error solver
//Note that the excess particles are the appended particle values which are not directly
//Invoked by the compute shader

#define PI 3.1415926
#define MAX_FLOAT 99999.0
#define LARGE_PRIME 721546
#define LOCAL_GROUP_SIZE 4

typedef struct __attribute__ ((packed)) _particle{
  float3 position;
  float3 velocity;
  float3 force;
  float pressure;
  float density;
}particle;

type struct __attribute__ ((packed)) _temp_particle{
  float3 vel;
  float3 pos;
  float density;
}temp_particle;

type struct __attribute__ ((packed))_intdata{
  int particles;
  int boundarys;
  int buckets;
  int bucket_size;
}intdata;

type struct __attribute__ ((packed))_floatdata{
  float time_step;
  float mass;
  float delta;
  float maxVel;
  float h0;
}floatdata;


//Kernel Functions
float f(float x, float h){
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x*x/h*h));
  return ((315.0)/(64*PI*h*h*h))*q*q;
}

float f(float x){
  float h = fluid_data.h0;
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x*x/h*h));
  return ((315.0)/(64*PI*h*h*h))*q*q;
}

float o1d(float x, float h){
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x/h));
  return ((-45.0)/(PI*h*h*h*h))*q*q;
}

float o1d(float x){
  float h = fluid_data.h0;
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x/h));
  return ((-45.0)/(PI*h*h*h*h))*q*q;
}

float o2d(float x, float h){
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x/h));
  return ((90.0)/(PI*h*h*h*h*h))*q;
}

float o2d(float x){
  float h = fluid_data.h0;
  if (x >= h){
    return 0.0;
  }
  float q = (1-(x/h));
  return ((90.0)/(PI*h*h*h*h*h))*q;
}

float3 f_grad(float x, float h,float3 dir){
  if (x >= h){
    return float3(0.0,0.0,0.0);
  }
  return -o1d(x,h)*dir;
}

float3 f_grad(float x, float3 dir){
  float h = fluid_data.h0;
  if (x >= h){
    return float3(0.0,0.0,0.0);
  }
  return -o1d(x,h)*dir;
}


//Hashing Function given hyperplane
int sgn(float x){
  if (x <= 0){
    return 0;
  }else{
    return 1;
  }
}

//Hashing Algorithm of LSH
int lsh_h(float3 v){
  int hash_val = 0;
  for(int i = 0; i < 8; i++){
    hash_val << 1;
    hash_val += sgn(dot(vectors.vec[i], v));
  }
  return hash_val;
}

int get_sample(float3 position, int offset){
  int m_hash = lsh_h(position);
  return locality.data[m_hash*sizes.buckets + offset];
}


float interp_density(float3 position){
  float sum = 0.0;
  for(int i = 0; i < 150; i++){
    int j = get_sample(position,i);
    if (j != 0){
      float x = length(position - fluid.particles[j].position);
      sum += fluid_data.mass * f(x, fluid_data.h0);
    }
  }
  return sum;
}

float particle_density(int x){
  float sum = f(0);
  for(int i = 0; i < 150; i++){
    int j = get_sample(fluid[x].position,i);
    if (j != 0){
      float x = length(fluid[x].position - fluid.particles[j].position);
      sum += fluid_data.mass * f(x);
    }
  }
  return sum;
}


float tait_eos(float x){
  float g = 7.16;
  float w = 2.15;
  float d0 = 1000.0;
  float p0 = 1013.25;
  float y = (w/g)*(pow(x/d0,g)-1.0);
  if (y <= 0.0) {
    return 0.0;
  }
  return y;
}

void evaluate_pressure(int particle){
      fluid.particles[particle].pressure = tait_eos(fluid[particle].density);
}

//Density Compute Shader
kernel void compute_density(global particle* fluid,
                            global int* mints,
                            global float* mfloats,
                            global int* hashmap,
                            global float3* vectors){
  int x = get_global_id(0);
  fluid[x].density = interp_density(fluid[x].position);
  evaluate_pressure(x);
}
